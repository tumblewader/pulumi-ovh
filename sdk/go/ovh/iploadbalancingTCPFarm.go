// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package ovh

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates a backend server group (farm) to be used by loadbalancing frontend(s)
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-ovh/sdk/go/ovh"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		lb, err := ovh.GetIPLoadbalancing(ctx, &GetIPLoadbalancingArgs{
// 			ServiceName: pulumi.StringRef("ip-1.2.3.4"),
// 			State:       pulumi.StringRef("ok"),
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		_, err = ovh.NewIPLoadbalancingTCPFarm(ctx, "farmname", &ovh.IPLoadbalancingTCPFarmArgs{
// 			DisplayName: pulumi.String("ingress-8080-gra"),
// 			ServiceName: pulumi.String(lb.Id),
// 			Zone:        pulumi.String("GRA"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type IPLoadbalancingTCPFarm struct {
	pulumi.CustomResourceState

	// Load balancing algorithm. `roundrobin` if null (`first`, `leastconn`, `roundrobin`, `source`)
	Balance pulumi.StringPtrOutput `pulumi:"balance"`
	// Readable label for loadbalancer farm
	DisplayName pulumi.StringPtrOutput `pulumi:"displayName"`
	// Port for backends to recieve traffic on.
	Port pulumi.IntPtrOutput `pulumi:"port"`
	// define a backend healthcheck probe
	Probe IPLoadbalancingTCPFarmProbePtrOutput `pulumi:"probe"`
	// The internal name of your IP load balancing
	ServiceName pulumi.StringOutput `pulumi:"serviceName"`
	// Stickiness type. No stickiness if null (`sourceIp`)
	Stickiness pulumi.StringPtrOutput `pulumi:"stickiness"`
	// Internal Load Balancer identifier of the vRack private network to attach to your farm, mandatory when your Load Balancer is attached to a vRack
	VrackNetworkId pulumi.IntPtrOutput `pulumi:"vrackNetworkId"`
	// Zone where the farm will be defined (ie. `GRA`, `BHS` also supports `ALL`)
	Zone pulumi.StringOutput `pulumi:"zone"`
}

// NewIPLoadbalancingTCPFarm registers a new resource with the given unique name, arguments, and options.
func NewIPLoadbalancingTCPFarm(ctx *pulumi.Context,
	name string, args *IPLoadbalancingTCPFarmArgs, opts ...pulumi.ResourceOption) (*IPLoadbalancingTCPFarm, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ServiceName == nil {
		return nil, errors.New("invalid value for required argument 'ServiceName'")
	}
	if args.Zone == nil {
		return nil, errors.New("invalid value for required argument 'Zone'")
	}
	var resource IPLoadbalancingTCPFarm
	err := ctx.RegisterResource("ovh:index/iPLoadbalancingTCPFarm:IPLoadbalancingTCPFarm", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIPLoadbalancingTCPFarm gets an existing IPLoadbalancingTCPFarm resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIPLoadbalancingTCPFarm(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IPLoadbalancingTCPFarmState, opts ...pulumi.ResourceOption) (*IPLoadbalancingTCPFarm, error) {
	var resource IPLoadbalancingTCPFarm
	err := ctx.ReadResource("ovh:index/iPLoadbalancingTCPFarm:IPLoadbalancingTCPFarm", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IPLoadbalancingTCPFarm resources.
type iploadbalancingTCPFarmState struct {
	// Load balancing algorithm. `roundrobin` if null (`first`, `leastconn`, `roundrobin`, `source`)
	Balance *string `pulumi:"balance"`
	// Readable label for loadbalancer farm
	DisplayName *string `pulumi:"displayName"`
	// Port for backends to recieve traffic on.
	Port *int `pulumi:"port"`
	// define a backend healthcheck probe
	Probe *IPLoadbalancingTCPFarmProbe `pulumi:"probe"`
	// The internal name of your IP load balancing
	ServiceName *string `pulumi:"serviceName"`
	// Stickiness type. No stickiness if null (`sourceIp`)
	Stickiness *string `pulumi:"stickiness"`
	// Internal Load Balancer identifier of the vRack private network to attach to your farm, mandatory when your Load Balancer is attached to a vRack
	VrackNetworkId *int `pulumi:"vrackNetworkId"`
	// Zone where the farm will be defined (ie. `GRA`, `BHS` also supports `ALL`)
	Zone *string `pulumi:"zone"`
}

type IPLoadbalancingTCPFarmState struct {
	// Load balancing algorithm. `roundrobin` if null (`first`, `leastconn`, `roundrobin`, `source`)
	Balance pulumi.StringPtrInput
	// Readable label for loadbalancer farm
	DisplayName pulumi.StringPtrInput
	// Port for backends to recieve traffic on.
	Port pulumi.IntPtrInput
	// define a backend healthcheck probe
	Probe IPLoadbalancingTCPFarmProbePtrInput
	// The internal name of your IP load balancing
	ServiceName pulumi.StringPtrInput
	// Stickiness type. No stickiness if null (`sourceIp`)
	Stickiness pulumi.StringPtrInput
	// Internal Load Balancer identifier of the vRack private network to attach to your farm, mandatory when your Load Balancer is attached to a vRack
	VrackNetworkId pulumi.IntPtrInput
	// Zone where the farm will be defined (ie. `GRA`, `BHS` also supports `ALL`)
	Zone pulumi.StringPtrInput
}

func (IPLoadbalancingTCPFarmState) ElementType() reflect.Type {
	return reflect.TypeOf((*iploadbalancingTCPFarmState)(nil)).Elem()
}

type iploadbalancingTCPFarmArgs struct {
	// Load balancing algorithm. `roundrobin` if null (`first`, `leastconn`, `roundrobin`, `source`)
	Balance *string `pulumi:"balance"`
	// Readable label for loadbalancer farm
	DisplayName *string `pulumi:"displayName"`
	// Port for backends to recieve traffic on.
	Port *int `pulumi:"port"`
	// define a backend healthcheck probe
	Probe *IPLoadbalancingTCPFarmProbe `pulumi:"probe"`
	// The internal name of your IP load balancing
	ServiceName string `pulumi:"serviceName"`
	// Stickiness type. No stickiness if null (`sourceIp`)
	Stickiness *string `pulumi:"stickiness"`
	// Internal Load Balancer identifier of the vRack private network to attach to your farm, mandatory when your Load Balancer is attached to a vRack
	VrackNetworkId *int `pulumi:"vrackNetworkId"`
	// Zone where the farm will be defined (ie. `GRA`, `BHS` also supports `ALL`)
	Zone string `pulumi:"zone"`
}

// The set of arguments for constructing a IPLoadbalancingTCPFarm resource.
type IPLoadbalancingTCPFarmArgs struct {
	// Load balancing algorithm. `roundrobin` if null (`first`, `leastconn`, `roundrobin`, `source`)
	Balance pulumi.StringPtrInput
	// Readable label for loadbalancer farm
	DisplayName pulumi.StringPtrInput
	// Port for backends to recieve traffic on.
	Port pulumi.IntPtrInput
	// define a backend healthcheck probe
	Probe IPLoadbalancingTCPFarmProbePtrInput
	// The internal name of your IP load balancing
	ServiceName pulumi.StringInput
	// Stickiness type. No stickiness if null (`sourceIp`)
	Stickiness pulumi.StringPtrInput
	// Internal Load Balancer identifier of the vRack private network to attach to your farm, mandatory when your Load Balancer is attached to a vRack
	VrackNetworkId pulumi.IntPtrInput
	// Zone where the farm will be defined (ie. `GRA`, `BHS` also supports `ALL`)
	Zone pulumi.StringInput
}

func (IPLoadbalancingTCPFarmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*iploadbalancingTCPFarmArgs)(nil)).Elem()
}

type IPLoadbalancingTCPFarmInput interface {
	pulumi.Input

	ToIPLoadbalancingTCPFarmOutput() IPLoadbalancingTCPFarmOutput
	ToIPLoadbalancingTCPFarmOutputWithContext(ctx context.Context) IPLoadbalancingTCPFarmOutput
}

func (*IPLoadbalancingTCPFarm) ElementType() reflect.Type {
	return reflect.TypeOf((**IPLoadbalancingTCPFarm)(nil)).Elem()
}

func (i *IPLoadbalancingTCPFarm) ToIPLoadbalancingTCPFarmOutput() IPLoadbalancingTCPFarmOutput {
	return i.ToIPLoadbalancingTCPFarmOutputWithContext(context.Background())
}

func (i *IPLoadbalancingTCPFarm) ToIPLoadbalancingTCPFarmOutputWithContext(ctx context.Context) IPLoadbalancingTCPFarmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPLoadbalancingTCPFarmOutput)
}

// IPLoadbalancingTCPFarmArrayInput is an input type that accepts IPLoadbalancingTCPFarmArray and IPLoadbalancingTCPFarmArrayOutput values.
// You can construct a concrete instance of `IPLoadbalancingTCPFarmArrayInput` via:
//
//          IPLoadbalancingTCPFarmArray{ IPLoadbalancingTCPFarmArgs{...} }
type IPLoadbalancingTCPFarmArrayInput interface {
	pulumi.Input

	ToIPLoadbalancingTCPFarmArrayOutput() IPLoadbalancingTCPFarmArrayOutput
	ToIPLoadbalancingTCPFarmArrayOutputWithContext(context.Context) IPLoadbalancingTCPFarmArrayOutput
}

type IPLoadbalancingTCPFarmArray []IPLoadbalancingTCPFarmInput

func (IPLoadbalancingTCPFarmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IPLoadbalancingTCPFarm)(nil)).Elem()
}

func (i IPLoadbalancingTCPFarmArray) ToIPLoadbalancingTCPFarmArrayOutput() IPLoadbalancingTCPFarmArrayOutput {
	return i.ToIPLoadbalancingTCPFarmArrayOutputWithContext(context.Background())
}

func (i IPLoadbalancingTCPFarmArray) ToIPLoadbalancingTCPFarmArrayOutputWithContext(ctx context.Context) IPLoadbalancingTCPFarmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPLoadbalancingTCPFarmArrayOutput)
}

// IPLoadbalancingTCPFarmMapInput is an input type that accepts IPLoadbalancingTCPFarmMap and IPLoadbalancingTCPFarmMapOutput values.
// You can construct a concrete instance of `IPLoadbalancingTCPFarmMapInput` via:
//
//          IPLoadbalancingTCPFarmMap{ "key": IPLoadbalancingTCPFarmArgs{...} }
type IPLoadbalancingTCPFarmMapInput interface {
	pulumi.Input

	ToIPLoadbalancingTCPFarmMapOutput() IPLoadbalancingTCPFarmMapOutput
	ToIPLoadbalancingTCPFarmMapOutputWithContext(context.Context) IPLoadbalancingTCPFarmMapOutput
}

type IPLoadbalancingTCPFarmMap map[string]IPLoadbalancingTCPFarmInput

func (IPLoadbalancingTCPFarmMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IPLoadbalancingTCPFarm)(nil)).Elem()
}

func (i IPLoadbalancingTCPFarmMap) ToIPLoadbalancingTCPFarmMapOutput() IPLoadbalancingTCPFarmMapOutput {
	return i.ToIPLoadbalancingTCPFarmMapOutputWithContext(context.Background())
}

func (i IPLoadbalancingTCPFarmMap) ToIPLoadbalancingTCPFarmMapOutputWithContext(ctx context.Context) IPLoadbalancingTCPFarmMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IPLoadbalancingTCPFarmMapOutput)
}

type IPLoadbalancingTCPFarmOutput struct{ *pulumi.OutputState }

func (IPLoadbalancingTCPFarmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IPLoadbalancingTCPFarm)(nil)).Elem()
}

func (o IPLoadbalancingTCPFarmOutput) ToIPLoadbalancingTCPFarmOutput() IPLoadbalancingTCPFarmOutput {
	return o
}

func (o IPLoadbalancingTCPFarmOutput) ToIPLoadbalancingTCPFarmOutputWithContext(ctx context.Context) IPLoadbalancingTCPFarmOutput {
	return o
}

type IPLoadbalancingTCPFarmArrayOutput struct{ *pulumi.OutputState }

func (IPLoadbalancingTCPFarmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IPLoadbalancingTCPFarm)(nil)).Elem()
}

func (o IPLoadbalancingTCPFarmArrayOutput) ToIPLoadbalancingTCPFarmArrayOutput() IPLoadbalancingTCPFarmArrayOutput {
	return o
}

func (o IPLoadbalancingTCPFarmArrayOutput) ToIPLoadbalancingTCPFarmArrayOutputWithContext(ctx context.Context) IPLoadbalancingTCPFarmArrayOutput {
	return o
}

func (o IPLoadbalancingTCPFarmArrayOutput) Index(i pulumi.IntInput) IPLoadbalancingTCPFarmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IPLoadbalancingTCPFarm {
		return vs[0].([]*IPLoadbalancingTCPFarm)[vs[1].(int)]
	}).(IPLoadbalancingTCPFarmOutput)
}

type IPLoadbalancingTCPFarmMapOutput struct{ *pulumi.OutputState }

func (IPLoadbalancingTCPFarmMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IPLoadbalancingTCPFarm)(nil)).Elem()
}

func (o IPLoadbalancingTCPFarmMapOutput) ToIPLoadbalancingTCPFarmMapOutput() IPLoadbalancingTCPFarmMapOutput {
	return o
}

func (o IPLoadbalancingTCPFarmMapOutput) ToIPLoadbalancingTCPFarmMapOutputWithContext(ctx context.Context) IPLoadbalancingTCPFarmMapOutput {
	return o
}

func (o IPLoadbalancingTCPFarmMapOutput) MapIndex(k pulumi.StringInput) IPLoadbalancingTCPFarmOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IPLoadbalancingTCPFarm {
		return vs[0].(map[string]*IPLoadbalancingTCPFarm)[vs[1].(string)]
	}).(IPLoadbalancingTCPFarmOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IPLoadbalancingTCPFarmInput)(nil)).Elem(), &IPLoadbalancingTCPFarm{})
	pulumi.RegisterInputType(reflect.TypeOf((*IPLoadbalancingTCPFarmArrayInput)(nil)).Elem(), IPLoadbalancingTCPFarmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IPLoadbalancingTCPFarmMapInput)(nil)).Elem(), IPLoadbalancingTCPFarmMap{})
	pulumi.RegisterOutputType(IPLoadbalancingTCPFarmOutput{})
	pulumi.RegisterOutputType(IPLoadbalancingTCPFarmArrayOutput{})
	pulumi.RegisterOutputType(IPLoadbalancingTCPFarmMapOutput{})
}
