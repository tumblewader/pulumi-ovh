// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package ovh

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to create a custom installation template available for dedicated servers.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-ovh/sdk/go/ovh"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := ovh.NewMeInstallationTemplate(ctx, "mytemplate", &ovh.MeInstallationTemplateArgs{
// 			BaseTemplateName: pulumi.String("centos7_64"),
// 			DefaultLanguage:  pulumi.String("fr"),
// 			TemplateName:     pulumi.String("mytemplate"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// Use the following id format to import the resource `base_template_name/template_name`
type MeInstallationTemplate struct {
	pulumi.CustomResourceState

	// List of all language available for this template
	AvailableLanguages pulumi.StringArrayOutput `pulumi:"availableLanguages"`
	// OVH template name yours will be based on, choose one among the list given by compatibleTemplates function
	BaseTemplateName pulumi.StringOutput `pulumi:"baseTemplateName"`
	// This distribution is new and, although tested and functional, may still display odd behaviour
	Beta pulumi.BoolOutput `pulumi:"beta"`
	// This template bit format (32 or 64)
	BitFormat pulumi.IntOutput `pulumi:"bitFormat"`
	// Category of this template (informative only). (basic, customer, hosting, other, readyToUse, virtualisation)
	Category      pulumi.StringOutput                          `pulumi:"category"`
	Customization MeInstallationTemplateCustomizationPtrOutput `pulumi:"customization"`
	// The default language of this template
	DefaultLanguage pulumi.StringOutput `pulumi:"defaultLanguage"`
	// is this distribution deprecated
	Deprecated pulumi.BoolOutput `pulumi:"deprecated"`
	// information about this template
	Description pulumi.StringOutput `pulumi:"description"`
	// the distribution this template is based on
	Distribution pulumi.StringOutput `pulumi:"distribution"`
	// this template family type (bsd,linux,solaris,windows)
	Family pulumi.StringOutput `pulumi:"family"`
	// Filesystems available (btrfs,ext3,ext4,ntfs,reiserfs,swap,ufs,xfs,zfs)
	Filesystems pulumi.StringArrayOutput `pulumi:"filesystems"`
	// This distribution supports hardware raid configuration through the OVH API
	HardRaidConfiguration pulumi.BoolOutput `pulumi:"hardRaidConfiguration"`
	// Date of last modification of the base image
	LastModification pulumi.StringOutput `pulumi:"lastModification"`
	// This distribution supports Logical Volumes (Linux LVM)
	LvmReady pulumi.BoolOutput `pulumi:"lvmReady"`
	// Remove default partition schemes at creation
	RemoveDefaultPartitionSchemes pulumi.BoolOutput `pulumi:"removeDefaultPartitionSchemes"`
	// This distribution supports installation using the distribution's native kernel instead of the recommended OVH kernel
	SupportsDistributionKernel pulumi.BoolOutput `pulumi:"supportsDistributionKernel"`
	// This distribution supports the GUID Partition Table (GPT), providing up to 128 partitions that can have more than 2TB
	SupportsGptLabel pulumi.BoolOutput `pulumi:"supportsGptLabel"`
	// This distribution supports RTM software
	SupportsRtm pulumi.BoolOutput `pulumi:"supportsRtm"`
	// This distribution supports the microsoft SQL server
	SupportsSqlServer pulumi.BoolOutput `pulumi:"supportsSqlServer"`
	// This distribution supports UEFI setup (no,only,yes)
	SupportsUefi pulumi.StringOutput `pulumi:"supportsUefi"`
	// This template name
	TemplateName pulumi.StringOutput `pulumi:"templateName"`
}

// NewMeInstallationTemplate registers a new resource with the given unique name, arguments, and options.
func NewMeInstallationTemplate(ctx *pulumi.Context,
	name string, args *MeInstallationTemplateArgs, opts ...pulumi.ResourceOption) (*MeInstallationTemplate, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.BaseTemplateName == nil {
		return nil, errors.New("invalid value for required argument 'BaseTemplateName'")
	}
	if args.DefaultLanguage == nil {
		return nil, errors.New("invalid value for required argument 'DefaultLanguage'")
	}
	if args.TemplateName == nil {
		return nil, errors.New("invalid value for required argument 'TemplateName'")
	}
	var resource MeInstallationTemplate
	err := ctx.RegisterResource("ovh:index/meInstallationTemplate:MeInstallationTemplate", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMeInstallationTemplate gets an existing MeInstallationTemplate resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMeInstallationTemplate(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MeInstallationTemplateState, opts ...pulumi.ResourceOption) (*MeInstallationTemplate, error) {
	var resource MeInstallationTemplate
	err := ctx.ReadResource("ovh:index/meInstallationTemplate:MeInstallationTemplate", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MeInstallationTemplate resources.
type meInstallationTemplateState struct {
	// List of all language available for this template
	AvailableLanguages []string `pulumi:"availableLanguages"`
	// OVH template name yours will be based on, choose one among the list given by compatibleTemplates function
	BaseTemplateName *string `pulumi:"baseTemplateName"`
	// This distribution is new and, although tested and functional, may still display odd behaviour
	Beta *bool `pulumi:"beta"`
	// This template bit format (32 or 64)
	BitFormat *int `pulumi:"bitFormat"`
	// Category of this template (informative only). (basic, customer, hosting, other, readyToUse, virtualisation)
	Category      *string                              `pulumi:"category"`
	Customization *MeInstallationTemplateCustomization `pulumi:"customization"`
	// The default language of this template
	DefaultLanguage *string `pulumi:"defaultLanguage"`
	// is this distribution deprecated
	Deprecated *bool `pulumi:"deprecated"`
	// information about this template
	Description *string `pulumi:"description"`
	// the distribution this template is based on
	Distribution *string `pulumi:"distribution"`
	// this template family type (bsd,linux,solaris,windows)
	Family *string `pulumi:"family"`
	// Filesystems available (btrfs,ext3,ext4,ntfs,reiserfs,swap,ufs,xfs,zfs)
	Filesystems []string `pulumi:"filesystems"`
	// This distribution supports hardware raid configuration through the OVH API
	HardRaidConfiguration *bool `pulumi:"hardRaidConfiguration"`
	// Date of last modification of the base image
	LastModification *string `pulumi:"lastModification"`
	// This distribution supports Logical Volumes (Linux LVM)
	LvmReady *bool `pulumi:"lvmReady"`
	// Remove default partition schemes at creation
	RemoveDefaultPartitionSchemes *bool `pulumi:"removeDefaultPartitionSchemes"`
	// This distribution supports installation using the distribution's native kernel instead of the recommended OVH kernel
	SupportsDistributionKernel *bool `pulumi:"supportsDistributionKernel"`
	// This distribution supports the GUID Partition Table (GPT), providing up to 128 partitions that can have more than 2TB
	SupportsGptLabel *bool `pulumi:"supportsGptLabel"`
	// This distribution supports RTM software
	SupportsRtm *bool `pulumi:"supportsRtm"`
	// This distribution supports the microsoft SQL server
	SupportsSqlServer *bool `pulumi:"supportsSqlServer"`
	// This distribution supports UEFI setup (no,only,yes)
	SupportsUefi *string `pulumi:"supportsUefi"`
	// This template name
	TemplateName *string `pulumi:"templateName"`
}

type MeInstallationTemplateState struct {
	// List of all language available for this template
	AvailableLanguages pulumi.StringArrayInput
	// OVH template name yours will be based on, choose one among the list given by compatibleTemplates function
	BaseTemplateName pulumi.StringPtrInput
	// This distribution is new and, although tested and functional, may still display odd behaviour
	Beta pulumi.BoolPtrInput
	// This template bit format (32 or 64)
	BitFormat pulumi.IntPtrInput
	// Category of this template (informative only). (basic, customer, hosting, other, readyToUse, virtualisation)
	Category      pulumi.StringPtrInput
	Customization MeInstallationTemplateCustomizationPtrInput
	// The default language of this template
	DefaultLanguage pulumi.StringPtrInput
	// is this distribution deprecated
	Deprecated pulumi.BoolPtrInput
	// information about this template
	Description pulumi.StringPtrInput
	// the distribution this template is based on
	Distribution pulumi.StringPtrInput
	// this template family type (bsd,linux,solaris,windows)
	Family pulumi.StringPtrInput
	// Filesystems available (btrfs,ext3,ext4,ntfs,reiserfs,swap,ufs,xfs,zfs)
	Filesystems pulumi.StringArrayInput
	// This distribution supports hardware raid configuration through the OVH API
	HardRaidConfiguration pulumi.BoolPtrInput
	// Date of last modification of the base image
	LastModification pulumi.StringPtrInput
	// This distribution supports Logical Volumes (Linux LVM)
	LvmReady pulumi.BoolPtrInput
	// Remove default partition schemes at creation
	RemoveDefaultPartitionSchemes pulumi.BoolPtrInput
	// This distribution supports installation using the distribution's native kernel instead of the recommended OVH kernel
	SupportsDistributionKernel pulumi.BoolPtrInput
	// This distribution supports the GUID Partition Table (GPT), providing up to 128 partitions that can have more than 2TB
	SupportsGptLabel pulumi.BoolPtrInput
	// This distribution supports RTM software
	SupportsRtm pulumi.BoolPtrInput
	// This distribution supports the microsoft SQL server
	SupportsSqlServer pulumi.BoolPtrInput
	// This distribution supports UEFI setup (no,only,yes)
	SupportsUefi pulumi.StringPtrInput
	// This template name
	TemplateName pulumi.StringPtrInput
}

func (MeInstallationTemplateState) ElementType() reflect.Type {
	return reflect.TypeOf((*meInstallationTemplateState)(nil)).Elem()
}

type meInstallationTemplateArgs struct {
	// OVH template name yours will be based on, choose one among the list given by compatibleTemplates function
	BaseTemplateName string                               `pulumi:"baseTemplateName"`
	Customization    *MeInstallationTemplateCustomization `pulumi:"customization"`
	// The default language of this template
	DefaultLanguage string `pulumi:"defaultLanguage"`
	// Remove default partition schemes at creation
	RemoveDefaultPartitionSchemes *bool `pulumi:"removeDefaultPartitionSchemes"`
	// This template name
	TemplateName string `pulumi:"templateName"`
}

// The set of arguments for constructing a MeInstallationTemplate resource.
type MeInstallationTemplateArgs struct {
	// OVH template name yours will be based on, choose one among the list given by compatibleTemplates function
	BaseTemplateName pulumi.StringInput
	Customization    MeInstallationTemplateCustomizationPtrInput
	// The default language of this template
	DefaultLanguage pulumi.StringInput
	// Remove default partition schemes at creation
	RemoveDefaultPartitionSchemes pulumi.BoolPtrInput
	// This template name
	TemplateName pulumi.StringInput
}

func (MeInstallationTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*meInstallationTemplateArgs)(nil)).Elem()
}

type MeInstallationTemplateInput interface {
	pulumi.Input

	ToMeInstallationTemplateOutput() MeInstallationTemplateOutput
	ToMeInstallationTemplateOutputWithContext(ctx context.Context) MeInstallationTemplateOutput
}

func (*MeInstallationTemplate) ElementType() reflect.Type {
	return reflect.TypeOf((**MeInstallationTemplate)(nil)).Elem()
}

func (i *MeInstallationTemplate) ToMeInstallationTemplateOutput() MeInstallationTemplateOutput {
	return i.ToMeInstallationTemplateOutputWithContext(context.Background())
}

func (i *MeInstallationTemplate) ToMeInstallationTemplateOutputWithContext(ctx context.Context) MeInstallationTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeInstallationTemplateOutput)
}

// MeInstallationTemplateArrayInput is an input type that accepts MeInstallationTemplateArray and MeInstallationTemplateArrayOutput values.
// You can construct a concrete instance of `MeInstallationTemplateArrayInput` via:
//
//          MeInstallationTemplateArray{ MeInstallationTemplateArgs{...} }
type MeInstallationTemplateArrayInput interface {
	pulumi.Input

	ToMeInstallationTemplateArrayOutput() MeInstallationTemplateArrayOutput
	ToMeInstallationTemplateArrayOutputWithContext(context.Context) MeInstallationTemplateArrayOutput
}

type MeInstallationTemplateArray []MeInstallationTemplateInput

func (MeInstallationTemplateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MeInstallationTemplate)(nil)).Elem()
}

func (i MeInstallationTemplateArray) ToMeInstallationTemplateArrayOutput() MeInstallationTemplateArrayOutput {
	return i.ToMeInstallationTemplateArrayOutputWithContext(context.Background())
}

func (i MeInstallationTemplateArray) ToMeInstallationTemplateArrayOutputWithContext(ctx context.Context) MeInstallationTemplateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeInstallationTemplateArrayOutput)
}

// MeInstallationTemplateMapInput is an input type that accepts MeInstallationTemplateMap and MeInstallationTemplateMapOutput values.
// You can construct a concrete instance of `MeInstallationTemplateMapInput` via:
//
//          MeInstallationTemplateMap{ "key": MeInstallationTemplateArgs{...} }
type MeInstallationTemplateMapInput interface {
	pulumi.Input

	ToMeInstallationTemplateMapOutput() MeInstallationTemplateMapOutput
	ToMeInstallationTemplateMapOutputWithContext(context.Context) MeInstallationTemplateMapOutput
}

type MeInstallationTemplateMap map[string]MeInstallationTemplateInput

func (MeInstallationTemplateMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MeInstallationTemplate)(nil)).Elem()
}

func (i MeInstallationTemplateMap) ToMeInstallationTemplateMapOutput() MeInstallationTemplateMapOutput {
	return i.ToMeInstallationTemplateMapOutputWithContext(context.Background())
}

func (i MeInstallationTemplateMap) ToMeInstallationTemplateMapOutputWithContext(ctx context.Context) MeInstallationTemplateMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeInstallationTemplateMapOutput)
}

type MeInstallationTemplateOutput struct{ *pulumi.OutputState }

func (MeInstallationTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MeInstallationTemplate)(nil)).Elem()
}

func (o MeInstallationTemplateOutput) ToMeInstallationTemplateOutput() MeInstallationTemplateOutput {
	return o
}

func (o MeInstallationTemplateOutput) ToMeInstallationTemplateOutputWithContext(ctx context.Context) MeInstallationTemplateOutput {
	return o
}

type MeInstallationTemplateArrayOutput struct{ *pulumi.OutputState }

func (MeInstallationTemplateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MeInstallationTemplate)(nil)).Elem()
}

func (o MeInstallationTemplateArrayOutput) ToMeInstallationTemplateArrayOutput() MeInstallationTemplateArrayOutput {
	return o
}

func (o MeInstallationTemplateArrayOutput) ToMeInstallationTemplateArrayOutputWithContext(ctx context.Context) MeInstallationTemplateArrayOutput {
	return o
}

func (o MeInstallationTemplateArrayOutput) Index(i pulumi.IntInput) MeInstallationTemplateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MeInstallationTemplate {
		return vs[0].([]*MeInstallationTemplate)[vs[1].(int)]
	}).(MeInstallationTemplateOutput)
}

type MeInstallationTemplateMapOutput struct{ *pulumi.OutputState }

func (MeInstallationTemplateMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MeInstallationTemplate)(nil)).Elem()
}

func (o MeInstallationTemplateMapOutput) ToMeInstallationTemplateMapOutput() MeInstallationTemplateMapOutput {
	return o
}

func (o MeInstallationTemplateMapOutput) ToMeInstallationTemplateMapOutputWithContext(ctx context.Context) MeInstallationTemplateMapOutput {
	return o
}

func (o MeInstallationTemplateMapOutput) MapIndex(k pulumi.StringInput) MeInstallationTemplateOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MeInstallationTemplate {
		return vs[0].(map[string]*MeInstallationTemplate)[vs[1].(string)]
	}).(MeInstallationTemplateOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MeInstallationTemplateInput)(nil)).Elem(), &MeInstallationTemplate{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeInstallationTemplateArrayInput)(nil)).Elem(), MeInstallationTemplateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeInstallationTemplateMapInput)(nil)).Elem(), MeInstallationTemplateMap{})
	pulumi.RegisterOutputType(MeInstallationTemplateOutput{})
	pulumi.RegisterOutputType(MeInstallationTemplateArrayOutput{})
	pulumi.RegisterOutputType(MeInstallationTemplateMapOutput{})
}
